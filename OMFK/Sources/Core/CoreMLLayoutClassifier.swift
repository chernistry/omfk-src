import Foundation
import CoreML
import NaturalLanguage

/// Wrapper for the CoreML LayoutClassifier model.
/// Provides the "Deep Path" for language detection.
public final class CoreMLLayoutClassifier {
    
    // MARK: - Constants
    
    // Must match Python `train.py` ALPHABET
    private static let alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 -=[]\\;',./`!@#$%^&*()_+{}|:\"<>?~"
        + "абвгдеёжзийклмнопрстуфхцчшщъыьэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"
        + "אבגדהוזחטיכלמנסעפצקרשתךםןףץ"
        
    private static let inputLength = 20  // Matched to train.py INPUT_LENGTH
    
    // Must match Python `train.py` CLASSES
    private static let classLabels = [
        "ru", "en", "he",
        "ru_from_en", "he_from_en",
        "en_from_ru", "en_from_he",
        "he_from_ru", "ru_from_he"
    ]
    
    private static let charToIndex: [Character: Int] = {
        var map = [Character: Int]()
        for (i, char) in CoreMLLayoutClassifier.alphabet.enumerated() {
            map[char] = i + 1 // 0 is padding
        }
        return map
    }()

    private static let compiledModelURL: URL? = {
        if let compiledURL = Bundle.module.url(forResource: "LayoutClassifier", withExtension: "mlmodelc") {
            return compiledURL
        }

        guard let sourceURL = Bundle.module.url(forResource: "LayoutClassifier", withExtension: "mlmodel") else {
            return nil
        }

        let fileManager = FileManager.default
        let cachesDir = fileManager.urls(for: .cachesDirectory, in: .userDomainMask).first
        let cachedCompiledURL = cachesDir?.appendingPathComponent("LayoutClassifier.mlmodelc", isDirectory: true)

        if let cachedCompiledURL, fileManager.fileExists(atPath: cachedCompiledURL.path) {
            return cachedCompiledURL
        }

        // Compile once and cache the compiled model directory to avoid repeated compilation cost.
        guard let compiledTempURL = try? MLModel.compileModel(at: sourceURL) else {
            return nil
        }

        if let cachedCompiledURL {
            do {
                try? fileManager.removeItem(at: cachedCompiledURL)
                try fileManager.copyItem(at: compiledTempURL, to: cachedCompiledURL)
                return cachedCompiledURL
            } catch {
                // Fall back to the temp compiled model location.
                return compiledTempURL
            }
        }

        return compiledTempURL
    }()
    
    private var model: MLModel?
    
    // MARK: - Initialization
    
    public init() {
        // Load model
        // Note: The class `LayoutClassifier` will be auto-generated by Xcode when the .mlmodel is added to the target.
        // However, since we are adding it dynamically or it might not be generated yet, 
        // we can try to load it by name or use the generated class if available.
        // For this implementation, we assume the generated class `LayoutClassifier` will exist.
        // If not, we fall back to generic loading behavior if possible, but strongly typed is better.
        
        do {
            let config = MLModelConfiguration()
            if let compiledURL = CoreMLLayoutClassifier.compiledModelURL {
                self.model = try MLModel(contentsOf: compiledURL, configuration: config)
            } else {
                print("CoreMLLayoutClassifier: Model not found with extension 'mlmodelc' or 'mlmodel'.")
                // Debug: List all resources
                if let resourcePath = Bundle.module.resourcePath {
                    print("Bundle resource path: \(resourcePath)")
                    let fm = FileManager.default
                    if let items = try? fm.contentsOfDirectory(atPath: resourcePath) {
                        print("Bundle contents: \(items)")
                    }
                }
            }
        } catch {
            print("CoreMLLayoutClassifier: Failed to load model: \(error)")
        }
    }
    
    // MARK: - Prediction
    
    /// Predicts the layout/language for the given text.
    /// - Returns: Tuple of (Hypothesis, Confidence) or nil if prediction fails.
    public func predict(_ text: String) -> (LanguageHypothesis, Double)? {
        guard let model = self.model else { 
            print("CoreMLLayoutClassifier: Model not loaded!")
            return nil 
        }
        
        // Tokenize
        let inputIds = tokenize(text)
        
        // Create Input
        // CoreML Expects MultiArray of shape [1, 12]
        guard let inputArray = try? MLMultiArray(shape: [1, NSNumber(value: CoreMLLayoutClassifier.inputLength)], dataType: .int32) else {
            return nil
        }
        
        for (i, val) in inputIds.enumerated() {
            inputArray[[0, NSNumber(value: i)]] = NSNumber(value: val)
        }
        
        // Run Prediction
        do {
            let input = try MLDictionaryFeatureProvider(dictionary: ["input_ids": inputArray])
            let output = try model.prediction(from: input)
            
            // Output is "classLogits" (Tensor) of shape [9] (or [1, 9] depending on export)
            // We need to find valid output feature.
            // If the model was exported as a classifier, it might have "classLabel" and "classProbability".
            // But our export.py defined "classLogits".
            
            guard let logits = output.featureValue(for: "classLogits")?.multiArrayValue else {
                print("CoreMLLayoutClassifier: No classLogits in output!")
                return nil
            }
            
            // Softmax
            let scores = softmax(logits)
            
            // Argmax
            let (maxIndex, maxScore) = argmax(scores)
            
            if maxIndex < CoreMLLayoutClassifier.classLabels.count {
                let label = CoreMLLayoutClassifier.classLabels[maxIndex]
                if let hypothesis = LanguageHypothesis(rawValue: label) {
                    return (hypothesis, maxScore)
                }
            }
            
            return nil
            
        } catch {
            print("CoreMLLayoutClassifier: Prediction error: \(error)")
            return nil
        }
    }
    
    // MARK: - Helpers
    
    private func tokenize(_ text: String) -> [Int] {
        var indices = [Int]()
        for char in text {
            if let idx = CoreMLLayoutClassifier.charToIndex[char] {
                indices.append(idx)
            } else {
                indices.append(0) // Unknown char -> padding/0
            }
        }
        
        // Pad or Truncate
        if indices.count > CoreMLLayoutClassifier.inputLength {
            return Array(indices.prefix(CoreMLLayoutClassifier.inputLength))
        } else {
            return indices + Array(repeating: 0, count: CoreMLLayoutClassifier.inputLength - indices.count)
        }
    }
    
    private func softmax(_ array: MLMultiArray) -> [Double] {
        let count = array.count
        var values = [Double]()
        for i in 0..<count {
            values.append(array[i].doubleValue)
        }
        
        let maxVal = values.max() ?? 0
        let expValues = values.map { exp($0 - maxVal) }
        let sumExp = expValues.reduce(0, +)
        
        return expValues.map { $0 / sumExp }
    }
    
    private func argmax(_ values: [Double]) -> (Int, Double) {
        var maxIndex = 0
        var maxValue = values[0]
        
        for (i, value) in values.enumerated() {
            if value > maxValue {
                maxValue = value
                maxIndex = i
            }
        }
        return (maxIndex, maxValue)
    }
}
